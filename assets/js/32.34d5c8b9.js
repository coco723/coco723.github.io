(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{453:function(t,T,_){"use strict";_.r(T);var a=_(2),i=Object(a.a)({},(function(){var t=this,T=t._self._c;return T("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[T("h1",{attrs:{id:"一个tcp连接可以发送多少个http请求"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#一个tcp连接可以发送多少个http请求"}},[t._v("#")]),t._v(" 一个TCP连接可以发送多少个HTTP请求")]),t._v(" "),T("h2",{attrs:{id:"q1-现代浏览器在与服务器建立了一个tcp连接后是和否会在一个http请求完成后断开-什么情况下会断开"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#q1-现代浏览器在与服务器建立了一个tcp连接后是和否会在一个http请求完成后断开-什么情况下会断开"}},[t._v("#")]),t._v(" Q1 现代浏览器在与服务器建立了一个TCP连接后是和否会在一个HTTP请求完成后断开？什么情况下会断开？")]),t._v(" "),T("p",[t._v("在HTTP/1.0中，一个服务器在发送完一个HTTP像影后，会断开TCP链接。但是这样每次请求都会重新建立和断开TCP连接，代价过大（TCP的三次握手四次挥手）。所以虽然标准中没有设定，某些服务器对Connection：keep-alive的Header进行了支持。意思是说，完成这个HTTP请求之后，不要断开HTTP请求使用TCP连接，以及如果维持连接，那么SSL的开销也可以避免，两张图篇是我短时间内两次反问https://github.com/")]),t._v(" "),T("p",[T("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://mmbiz.qpic.cn/mmbiz_jpg/8Jeic82Or04kzuVt4sxB6wvha4kH2Rxbu9n33RJTvpH4hw8rqMKuqIF1NhFDgk1VEJLMORr4NJ5nQ2O1MwP3Beg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1",loading:"lazy"}})]),t._v(" "),T("p",[t._v("初始化连接和SSL开销小时了，说明使用的是同一个TCP连接")]),t._v(" "),T("p",[t._v("持久连接：既然维持TCP连接好处这么多，HTTP/1.1就把Connection头写进标准，并且默认开启持久连接，除非请求中写明Connection：close，那么浏览器和服务器之间是会维持一段时间的TCP连接，不会一个请求结束就会断开")]),t._v(" "),T("blockquote",[T("p",[t._v("R1: 默认情况下建立TCP连接不会断开，只有在请求报头中声名Connection：close才会在请求完成后关闭连接。")])]),t._v(" "),T("h2",{attrs:{id:"q2-一个tcp连接可以对应几个http请求"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#q2-一个tcp连接可以对应几个http请求"}},[t._v("#")]),t._v(" Q2 一个TCP连接可以对应几个HTTP请求？")]),t._v(" "),T("blockquote",[T("p",[t._v("R2：如果维持连接，一个TCP连接是可以发送多个HTTP请求的。")])]),t._v(" "),T("h2",{attrs:{id:"q3-一个tcp连接中http请求可以一起发送吗-比如一起发三个请求-在三个响应一起接收"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#q3-一个tcp连接中http请求可以一起发送吗-比如一起发三个请求-在三个响应一起接收"}},[t._v("#")]),t._v(" Q3 一个TCP连接中HTTP请求可以一起发送吗（比如一起发三个请求，在三个响应一起接收）？")]),t._v(" "),T("p",[t._v("HTTP/1.1存在一个问题，单个TCP连接在同一时刻只能处理一个请求，意思是说，两个请求的生命周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里不能重叠。")]),t._v(" "),T("p",[t._v("虽然HTTP/1.1规范中规定了Pipelining来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。")]),t._v(" "),T("p",[t._v("先来看一下Pipelining是什么，RFC2616中规定了：")]),t._v(" "),T("blockquote",[T("p",[t._v("一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应【翻译】")])]),t._v(" "),T("p",[t._v("至于标准为什么这么设定，我们可以大概推测一个原因，由于HTTP/1.1是个文本协议，同时返回的内容并不能区分对应于哪个发送的请求，所以顺序必须一致。服务器返回两个结果浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。")]),t._v(" "),T("p",[t._v("Pipelining这种设想看起来比较美好，但是在实践中会出现许多问题：")]),t._v(" "),T("ul",[T("li",[t._v("一些代理服务器不能正确的处理HTTP Pipelinling。")]),t._v(" "),T("li",[t._v("正确的流水线实现是复杂的。")]),t._v(" "),T("li",[t._v("Head-of-line Blocking 连接头阻塞：在建立期一个TCP连接之后，假设客户端在这个连接连续向服务器发送几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求花费了大量时间，那么后面所欲的请求都需要等着这个请求结束后才能响应。")])]),t._v(" "),T("p",[t._v("所以现代浏览器默认是不开启HTTP Pipelining的。")]),t._v(" "),T("p",[t._v("但是，HTTP2提供了 Multiplexing 多路传输特性，可以在一个TCP连接中同时完成多个HTTP请求。至于Multiplexing具体怎么实现的就是另一个问题了。我们可以看一下使用HTTP2的效果。")]),t._v(" "),T("p",[T("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://mmbiz.qpic.cn/mmbiz_jpg/8Jeic82Or04kzuVt4sxB6wvha4kH2RxbuerYia3tGhhUFeicSxWLnRWwgQ5JoDdBFCiapjUCe9Uk2rUibzTSf0VSeKQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1",loading:"lazy"}})]),t._v(" "),T("p",[t._v("绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个Connection，并行完成的。")]),t._v(" "),T("blockquote",[T("p",[t._v("R3: 在HTTP/1.1存在Pipelinling技术可以完成这个多个请求同时发送，但是由于浏览器默认是关闭的，所以可以认为是不可行的。在HTTP2中由于Multiplexing特点的寻在，多个HTTP请求是可以在同一个TCP连接中并行进行")])]),t._v(" "),T("p",[t._v("那么在HTTP/1.1时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：")]),t._v(" "),T("ul",[T("li",[t._v("维持和服务器已经建立的TCP 连接，在同一连接上顺序处理多个请求。")]),t._v(" "),T("li",[t._v("和服务器建立多个TCP连接")])]),t._v(" "),T("h2",{attrs:{id:"q4-为什么有的时候刷新页面不需要重新建立ssl连接"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#q4-为什么有的时候刷新页面不需要重新建立ssl连接"}},[t._v("#")]),t._v(" Q4 为什么有的时候刷新页面不需要重新建立SSL连接？")]),t._v(" "),T("blockquote",[T("p",[t._v("R4 TCP连接有的时候会被浏览器和服务端维持一段时间。TCP不需要重新建立，SSL自然也会用之前的。")])]),t._v(" "),T("h2",{attrs:{id:"q5-浏览器对同一host建立tcp连接的数量有没有限制"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#q5-浏览器对同一host建立tcp连接的数量有没有限制"}},[t._v("#")]),t._v(" Q5 浏览器对同一Host建立TCP连接的数量有没有限制？")]),t._v(" "),T("p",[t._v("假设我们还处在HTTP/1.1时代，哪个时候没有多路传输，当浏览器拿到一个有几十张图片的网页的时候该怎么办？肯定不能只开一个TCP连接顺序下载，那样用户肯定等的难受，但是如果每个图片都开一个TCP连接发HTTP请求，那电脑或者服务器都可能受不了，要是有1000张图片的话不能开1000个TCP连接吧，你的电脑同意NAT也不一定会同意")]),t._v(" "),T("blockquote",[T("p",[t._v("所以答案是：有，Chrome最多允许对同意Host建立六个TCP连接。不同浏览器有一些区别")])]),t._v(" "),T("h2",{attrs:{id:"总结"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),T("p",[t._v("那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？")]),t._v(" "),T("p",[t._v("如果图片都是HTTPS连接并且在同一个域名下，那么浏览器在SSL握手之后会和服务器商量能不能用HTTP2，如果能的话就是用Multiplexing功能在这个连接上进行多路传输。不过也未必会有挂在这个域名的资源都会使用一个TCP连接区获取，但是可以确定的是Multiplexing很可能回用到")]),t._v(" "),T("p",[t._v("如果发现用不了HTTP2呢？ 或者用不了HTTPS（实际场景中HTTP2都是在HTTPS上实现的，所以也就是只能使用HTTP/1.1）那浏览器就会在一个HOST上建立多个TCP连接，连接数量的最大限制取决于浏览器的设置，这些连接会在空闲的时候被连览器用来发送新的请求，如果所有的连接都正在发送请求呢？ 那其他请求就只能等等了。")])])}),[],!1,null,null,null);T.default=i.exports}}]);